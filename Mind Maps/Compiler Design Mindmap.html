<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.1-alpha.4/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.17.1-alpha.4/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.1-alpha.4/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:q,mm:v}=window,j=new q.Toolbar;j.attach(v);const we=j.render();we.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(we)})})()</script><script>((f,d,h,u)=>{const g=f();window.mm=g.Markmap.create("svg#mindmap",(d||g.deriveOptions)(u),h)})(()=>window.markmap,null,{"content":"<a href=\"https://www.notion.so/GATE-2025-a84ab6d79cf141a4b0b5873933034747?pvs=21\">Compiler Design Mind Map by Nishant</a>","children":[{"content":"Introduction","children":[{"content":"what is compiler","children":[],"payload":{"lines":"3,4"}},{"content":"what is translator","children":[],"payload":{"lines":"4,5"}},{"content":"what is preprocessor and its tasks","children":[],"payload":{"lines":"5,6"}},{"content":"what are Dynamic Link Libraries","children":[],"payload":{"lines":"6,7"}},{"content":"phases of compiler ( input and output of each phase )","children":[],"payload":{"lines":"7,8"}},{"content":"what is linker and its tasks","children":[],"payload":{"lines":"8,9"}},{"content":"what is loader and its tasks","children":[],"payload":{"lines":"9,10"}},{"content":"Errors","children":[{"content":"preprocessor errors","children":[],"payload":{"lines":"11,12"}},{"content":"compiler errors","children":[{"content":"lexical","children":[],"payload":{"lines":"13,14"}},{"content":"syntax","children":[],"payload":{"lines":"14,15"}},{"content":"sementic","children":[],"payload":{"lines":"15,16"}}],"payload":{"lines":"12,16"}},{"content":"linker errors","children":[],"payload":{"lines":"16,17"}},{"content":"runtime errors","children":[],"payload":{"lines":"17,18"}}],"payload":{"lines":"10,18"}},{"content":"2 pass compiler architecture and its advantages","children":[],"payload":{"lines":"18,19"}}],"payload":{"lines":"2,19"}},{"content":"1st pass ( High level Code → Intermediate Code ) ( hardware independent ) (4 phases )","children":[{"content":"Lexical Analysis","children":[{"content":"what happens in this phase ? ( character stream → token stream (longest Prefix rule) ) → its checked if valid “words” are given as input","children":[],"payload":{"lines":"21,22"}},{"content":"symbol table created here . but used in every phase","children":[],"payload":{"lines":"22,23"}},{"content":"what is symbol table &amp; its structure","children":[],"payload":{"lines":"23,24"}},{"content":"Types of tokens","children":[{"content":"keywords | ( sizeOf is a keyword and an operator but (exit,main) are not keywords)","children":[],"payload":{"lines":"25,26"}},{"content":"operators","children":[],"payload":{"lines":"26,27"}},{"content":"identifiers ( rules of valid identifer )","children":[],"payload":{"lines":"27,28"}},{"content":"constants (rules of valid constants (ex: number in ocatl can have digit(x) : 0≤ x ≤7 only )","children":[],"payload":{"lines":"28,29"}},{"content":"special tokens","children":[],"payload":{"lines":"29,30"}}],"payload":{"lines":"24,30"}},{"content":"counting / finding tokens from the input string","children":[],"payload":{"lines":"30,31"}},{"content":"lexical error examples","children":[],"payload":{"lines":"31,32"}}],"payload":{"lines":"20,32"}},{"content":"Syntax Analysis","children":[{"content":"what happens in this phase ? ( token stream → parse tree ) → its checked if valid “grammar” (structure) is being followed","children":[],"payload":{"lines":"33,34"}},{"content":"finding syntax error in code","children":[],"payload":{"lines":"34,35"}},{"content":"CFG ( context free grammar )","children":[{"content":"\n<p data-lines=\"36,37\">CFG = ( Variables , Terminals , Productions , Start symbol ) | production rule of valid CFG | V → (T U V)*</p>","children":[],"payload":{"lines":"36,37"}},{"content":"\n<p data-lines=\"37,38\">used here since it deals with structure only ( i.e no context needed/checked here ) ( CFG vs CSG)</p>","children":[],"payload":{"lines":"37,38"}},{"content":"\n<p data-lines=\"38,39\">Derivation of string</p>","children":[{"content":"Linear → ( Left most derivation &amp; Right most derivation )","children":[],"payload":{"lines":"39,40"}},{"content":"Non - Linear → ( Parse tree )","children":[],"payload":{"lines":"40,41"}}],"payload":{"lines":"38,41"}},{"content":"\n<p data-lines=\"41,42\">Ambiguity of grammar | Trick : if left and right recursion with same source variable then grammar will be always ambigious</p>","children":[],"payload":{"lines":"41,42"}},{"content":"\n<p data-lines=\"42,43\">logic and formula for elemination of left recursion (direct &amp; indirect) ( since infinite loop when using LMD with grammar having left recursion )</p>\n<pre><code data-lines=\"44,52\"><span class=\"hljs-selector-tag\">Original</span> <span class=\"hljs-selector-tag\">Production</span>: \n<span class=\"hljs-selector-tag\">A</span> → <span class=\"hljs-selector-tag\">A</span>α<span class=\"hljs-number\">1</span> | <span class=\"hljs-selector-tag\">A</span>α<span class=\"hljs-number\">2</span> |... <span class=\"hljs-selector-tag\">A</span>α<span class=\"hljs-selector-tag\">n</span> | β<span class=\"hljs-number\">1</span> | β<span class=\"hljs-number\">2</span> |... β<span class=\"hljs-selector-tag\">m</span> \n\n<span class=\"hljs-selector-tag\">Transformed</span> <span class=\"hljs-selector-tag\">Productions</span>:\n<span class=\"hljs-selector-tag\">A</span> → β<span class=\"hljs-number\">1</span><span class=\"hljs-selector-tag\">X</span> | β<span class=\"hljs-number\">2</span><span class=\"hljs-selector-tag\">X</span> |... β<span class=\"hljs-selector-tag\">mX</span>\n<span class=\"hljs-selector-tag\">X</span> → α<span class=\"hljs-number\">1</span><span class=\"hljs-selector-tag\">X</span>| α<span class=\"hljs-number\">2</span><span class=\"hljs-selector-tag\">X</span> |... α<span class=\"hljs-selector-tag\">nX</span> | ε\n</code></pre>","children":[],"payload":{"lines":"42,53"}},{"content":"\n<p data-lines=\"53,54\">left factoring ( removing common left prefix to prevent backtracking problem in top down parser )</p>","children":[],"payload":{"lines":"53,54"}},{"content":"\n<p data-lines=\"54,55\">how to calculate FIRST(…) SET</p>","children":[],"payload":{"lines":"54,55"}},{"content":"\n<p data-lines=\"55,56\">how to calculate FOLLOW(…) SET</p>","children":[],"payload":{"lines":"55,56"}}],"payload":{"lines":"35,56"}},{"content":"Parsers ( syntax analyzers )","children":[{"content":"what is parser ?","children":[],"payload":{"lines":"57,58"}},{"content":"TDP vs BUP","children":[],"payload":{"lines":"58,59"}},{"content":"structure of parsers ( input string , stack , parsing algorithm , symbol table )","children":[],"payload":{"lines":"59,60"}},{"content":"Top down parsers (TDPs)","children":[{"content":"Reads Left to right &amp; follows LMD | start from S and produce the string","children":[],"payload":{"lines":"61,62"}},{"content":"LL1 parser ( Left to right read , Left most derivateion , 1 look ahead )","children":[{"content":"ways to implemnt LL1","children":[{"content":"recursive | every production will have a recursive function associated with it","children":[],"payload":{"lines":"64,65"}},{"content":"tabular | every production will be stored in a table","children":[],"payload":{"lines":"65,66"}}],"payload":{"lines":"63,66"}},{"content":"How to write LL1 CFG | unambigous CFG → non left recursive CFG → left factored CFG → LL1 table → atmost 1 entry in each cell","children":[],"payload":{"lines":"66,67"}},{"content":"How to create LL1 Table | compute first set of all V → if null production in any first(x) then compute follow(x) → fill the table using FIRST and FOLLOW sets","children":[],"payload":{"lines":"67,68"}},{"content":"How to identify LL1 CFG","children":[{"content":"theory | unambigous CFG &amp; non left recursive CFG &amp; left factored CFG &amp; LL1 table &amp; atmost 1 entry in each cell","children":[],"payload":{"lines":"69,70"}},{"content":"Trick","children":[{"content":"X → a | B | c | D .. ( then intersection of first set of every pair of the production should be null )","children":[],"payload":{"lines":"71,72"}},{"content":"X → a | B | c | null …. (then check 1 &amp; intersection of first set of every production and follow set of X must be null )","children":[],"payload":{"lines":"72,73"}}],"payload":{"lines":"70,73"}}],"payload":{"lines":"68,73"}},{"content":"necessary &amp; sufficient condition for CFG to be LL1 ( each cell in LL1 table have atmost 1 entry )","children":[],"payload":{"lines":"73,74"}},{"content":"LL parsing algorithm","children":[{"content":"if <code>st.top() == V</code> , then <code>st.pop()</code> , and <code>push (Table[V,input[ptr]]</code>) in stack in reverse order","children":[],"payload":{"lines":"75,76"}},{"content":"if <code>st.top() == T</code> , then <code>st.pop()</code>, and <code>ptr++</code>","children":[],"payload":{"lines":"76,77"}}],"payload":{"lines":"74,77"}},{"content":"Conflits in LL1 parsing","children":[{"content":"N ( non terminal ) conflict | <code>st.top() == V &amp;&amp; table[V,input[ptr]] == NULL</code>","children":[],"payload":{"lines":"78,79"}},{"content":"T ( terminal ) conflict | <code>st.top() == T &amp;&amp; st.top() ≠ input[ptr]</code>","children":[],"payload":{"lines":"79,80"}}],"payload":{"lines":"77,80"}}],"payload":{"lines":"62,80"}},{"content":"LL(k) parsers and properties","children":[{"content":"k tells the lookahed i.e length of common prefix which algo can diffentiate , ex k == 2 then it will be able to diffrentiate between ab &amp; ac .","children":[],"payload":{"lines":"81,82"}},{"content":"every LL(K) CFG is LL(K+1)","children":[],"payload":{"lines":"82,83"}},{"content":"every LL(K) CFG can be converted to LL(1) cfg","children":[],"payload":{"lines":"83,84"}}],"payload":{"lines":"80,84"}},{"content":"for every DCFL (deterministic context free language) , LL1 CFG exists and every LL1 CFG produces a DCFL","children":[],"payload":{"lines":"84,85"}}],"payload":{"lines":"60,85"}},{"content":"Bottom up parsers (BUPs)","children":[{"content":"Reads Left to right &amp; follows RMD in Reverse  | start from input string and come to S","children":[],"payload":{"lines":"86,87"}},{"content":"different parsers","children":[{"content":"LR0 ( Left to right read , RMD in reverse , 0 look ahead )","children":[],"payload":{"lines":"88,89"}},{"content":"SLR ( Simple , Left to Right read , RMD in reverse )","children":[],"payload":{"lines":"89,90"}},{"content":"CLR ( Canonical i.e. exact , Left to Right read , RMD in reverse ) also called LR(1)","children":[],"payload":{"lines":"90,91"}},{"content":"LALR (Look ahead , LR (1) )","children":[],"payload":{"lines":"91,92"}}],"payload":{"lines":"87,92"}},{"content":"DFA construction for different BUPs","children":[{"content":"shift , reduce , accept items","children":[],"payload":{"lines":"93,94"}},{"content":"Calculating Closure","children":[],"payload":{"lines":"94,95"}},{"content":"Calculating GOTO","children":[],"payload":{"lines":"95,96"}},{"content":"Calculating Look Ahead ( only for CLR and LALR )","children":[],"payload":{"lines":"96,97"}},{"content":"Note : DFA for LR0 &amp; SLR &amp; LALR are same ( but LALR also have lookahead set along with the productions )","children":[],"payload":{"lines":"97,98"}},{"content":"Note : after joining common states of CLR’s DFA we get LALR’s DFA","children":[],"payload":{"lines":"98,99"}}],"payload":{"lines":"92,99"}},{"content":"Conflicts in differnet BUP","children":[{"content":"Shift Reduce Confict (SR)","children":[{"content":"LR0 → if both shift and reduce item in same state","children":[],"payload":{"lines":"101,102"}},{"content":"SLR → if shift terminal belong to follow set of reduced production","children":[],"payload":{"lines":"102,103"}},{"content":"CLR , LALR→ if shift terminal belong to look ahead set of reduced production","children":[],"payload":{"lines":"103,104"}}],"payload":{"lines":"100,104"}},{"content":"Reduce Reduce Confict (RR)","children":[{"content":"LR0 → if ≥2 Reduce item in a state","children":[],"payload":{"lines":"105,106"}},{"content":"SLR → if intersection of follow sets of reduced production is not empty","children":[],"payload":{"lines":"106,107"}},{"content":"CLR , LALR→ if intersectino of look ahead set of reduced productions is not empty","children":[],"payload":{"lines":"107,108"}}],"payload":{"lines":"104,108"}}],"payload":{"lines":"99,108"}},{"content":"what error is possible &amp; impossible  when CLR’s states are merged to create LALR respectively ? → RR &amp; SR","children":[],"payload":{"lines":"108,109"}},{"content":"Table consruction","children":[{"content":"action table","children":[{"content":"shift entries","children":[],"payload":{"lines":"111,112"}},{"content":"accept entries","children":[],"payload":{"lines":"112,113"}},{"content":"reduce entries ( different for LR0 , SLR , LALR , CLR )","children":[],"payload":{"lines":"113,114"}}],"payload":{"lines":"110,114"}},{"content":"Goto table → goto entry","children":[],"payload":{"lines":"114,115"}}],"payload":{"lines":"109,115"}},{"content":"LR parsing Algorithm","children":[],"payload":{"lines":"115,116"}}],"payload":{"lines":"85,116"}},{"content":"Relations among different ( parsers , grammars , classes of language generated by grammars )","children":[{"content":"Paresers Power","children":[{"content":"LR0 &lt; SLR &lt; LALR &lt; CLR","children":[],"payload":{"lines":"118,119"}},{"content":"LL1 &lt; CLR","children":[],"payload":{"lines":"119,120"}}],"payload":{"lines":"117,120"}},{"content":"Grammars (one way implications)","children":[{"content":"LR0 → SLR → LALR → CLR → Unambigious","children":[],"payload":{"lines":"121,122"}},{"content":"LL1 → CLR → Unambigious","children":[],"payload":{"lines":"122,123"}}],"payload":{"lines":"120,123"}},{"content":"Language Classes ( Set of language produced by corresponding grammars ) Language(G)","children":[{"content":"Language(LR0) ⊂ Language(SLR) ⊂ Language(LALR) ⊂ Language(CLR) ⊂ Language(Unambigious grammar)","children":[],"payload":{"lines":"124,125"}},{"content":"Language(LL1) ⊂ Language(CLR) ⊂ Language(Unambigious grammar)","children":[],"payload":{"lines":"125,126"}}],"payload":{"lines":"123,126"}}],"payload":{"lines":"116,126"}}],"payload":{"lines":"56,126"}},{"content":"Precedence Relations","children":[{"content":"what is precedence relation → tells us order of resolving operator evaluations","children":[],"payload":{"lines":"127,128"}},{"content":"how to calculate prioirty &amp; associativity of operators → ( use precidence table ) | ( trick : left / right recursion with operator then that operator is left / right associative , respectively )","children":[],"payload":{"lines":"128,129"}},{"content":"what is operator grammar → no null production and no 2 non-terminal together","children":[],"payload":{"lines":"129,130"}}],"payload":{"lines":"126,130"}},{"content":"CYK algo → member ship algo of CFG ( tells if string w belongs to L(G) , where G is CFG ) → time complexity O(n^3)","children":[],"payload":{"lines":"130,131"}}],"payload":{"lines":"32,131"}},{"content":"Syntax Directed Translation ( also used for sementic analysis )","children":[{"content":"Syntax ( CFG i.e. grammar ) + Directed ( since order of productions and translation matters ) + Translation ( giving meaning to production rules , ex A→B#C means A = B+C or B*C )","children":[],"payload":{"lines":"132,133"}},{"content":"application of SDTs","children":[],"payload":{"lines":"133,134"}},{"content":"lexitcal Vs Syntax Vs Sementic Vs SDT","children":[],"payload":{"lines":"134,135"}},{"content":"Type of Attributes ( Inherited (derived from sibling or parent) , Synthesized (derived from child))","children":[],"payload":{"lines":"135,136"}},{"content":"Type of SDTs ( L - attributed , S - attributed ) → depends on location of Translation and type of attributes","children":[],"payload":{"lines":"136,137"}},{"content":"Evaluation of SDTs ( Left to right ( depends on Translation order ) , Bottom up parsing ( reverse of RMD ) , Top down parsing ( LMD) , NOTE : BUP and TDP evalutaions , doesnt depend on translation order )","children":[],"payload":{"lines":"137,138"}},{"content":"if givent SDTs is ambigious it’s possible we get multiple output at root for the same input , thus we have to check for that too and select answer accordingly","children":[],"payload":{"lines":"138,139"}}],"payload":{"lines":"131,139"}},{"content":"Intermediate Code Generation","children":[{"content":"Intermediate Code representation ( postfix , Three Adress Code , Static Single Assignment , Syntax Tree , Directed Acyclic Graph , Control Flow Graph )","children":[],"payload":{"lines":"140,141"}},{"content":"Three Adress Code Notation ( triple , quadruple , indirect triple )","children":[],"payload":{"lines":"141,142"}},{"content":"Three Adress Code for ( if - else , while loop , accessing 2d array element )","children":[],"payload":{"lines":"142,143"}},{"content":"Control Flow Graph → consists of nodes &amp; edges &amp; Basic Blocks ( control must enter and exit the block at the 1st and last stement respetively &amp; the control must not exit / enter the block in / from middle )","children":[],"payload":{"lines":"143,144"}}],"payload":{"lines":"139,144"}}],"payload":{"lines":"19,144"}},{"content":"2nd pass ( Intermediate Code → Target Code ) ( hardware dependent ) (3 phases)","children":[{"content":"Intermediate Code optimisation","children":[{"content":"optimization techniques","children":[{"content":"constant folding","children":[],"payload":{"lines":"147,148"}},{"content":"copy propogation → constant &amp; variable","children":[],"payload":{"lines":"148,149"}},{"content":"common subexpression elemination","children":[],"payload":{"lines":"149,150"}},{"content":"strength reduction","children":[],"payload":{"lines":"150,151"}},{"content":"algebraic simplifications","children":[],"payload":{"lines":"151,152"}},{"content":"dead code elemination","children":[],"payload":{"lines":"152,153"}},{"content":"loop optimisation → code motion , induction variable elemniation , loop mergin , loop unrolling","children":[],"payload":{"lines":"153,154"}}],"payload":{"lines":"146,154"}},{"content":"Data Flow Analysis","children":[{"content":"Live variable analysis","children":[{"content":"what is a live variable ?","children":[],"payload":{"lines":"156,157"}},{"content":"calculating live variable at a statement Si","children":[],"payload":{"lines":"157,158"}}],"payload":{"lines":"155,158"}},{"content":"Backward analysis to obtain live variable at start and end of every Basic Block in the code","children":[{"content":"KILL , GEN , IN , OUT sets calculation","children":[],"payload":{"lines":"159,160"}},{"content":"INk = (OUTk - KILLk) U GENk","children":[],"payload":{"lines":"160,161"}},{"content":"OUTk = union of all the INset of its next Basic blocks","children":[],"payload":{"lines":"161,162"}}],"payload":{"lines":"158,162"}},{"content":"Reaching Definition","children":[{"content":"USE-DEF chain ( where read → where write )","children":[],"payload":{"lines":"163,164"}},{"content":"DEF-USE chain ( where write → where read )","children":[],"payload":{"lines":"164,165"}}],"payload":{"lines":"162,165"}},{"content":"Dominator Sequence , Tree , elements","children":[],"payload":{"lines":"165,166"}}],"payload":{"lines":"154,166"}}],"payload":{"lines":"145,166"}},{"content":"Aseembly Code Generation ( Intermediate code → assembly Code )","children":[{"content":"hardware dependent , must have knowledge of H/w architecture","children":[],"payload":{"lines":"167,168"}},{"content":"register allocation using graph colouring algorithm","children":[],"payload":{"lines":"168,169"}}],"payload":{"lines":"166,169"}},{"content":"Aseembly Code optimization","children":[],"payload":{"lines":"169,170"}}],"payload":{"lines":"144,170"}},{"content":"Runtime environment","children":[{"content":"parameter passing ( by value &amp; by reference )","children":[],"payload":{"lines":"171,172"}},{"content":"memory alloation ( static , dynamic ( stack , heap ) )","children":[],"payload":{"lines":"172,173"}},{"content":"activation record","children":[],"payload":{"lines":"173,174"}}],"payload":{"lines":"170,174"}}],"payload":{"lines":"1,174"}},{"initialExpandLevel":2})</script>
</body>
</html>
