<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.1-alpha.4/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.17.1-alpha.4/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.1-alpha.4/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:q,mm:v}=window,j=new q.Toolbar;j.attach(v);const we=j.render();we.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(we)})})()</script><script>((f,d,h,u)=>{const g=f();window.mm=g.Markmap.create("svg#mindmap",(d||g.deriveOptions)(u),h)})(()=>window.markmap,null,{"content":"Compiler Design","children":[{"content":"Introduction","children":[{"content":"what is compiler","children":[],"payload":{"lines":"2,3"}},{"content":"what is translator","children":[],"payload":{"lines":"3,4"}},{"content":"what is preprocessor and its tasks","children":[],"payload":{"lines":"4,5"}},{"content":"phases of compiler","children":[],"payload":{"lines":"5,6"}},{"content":"what is linker and its tasks","children":[],"payload":{"lines":"6,7"}},{"content":"what is loader and its tasks","children":[],"payload":{"lines":"7,8"}},{"content":"Errors","children":[{"content":"preprocessor errors","children":[],"payload":{"lines":"9,10"}},{"content":"compiler errors","children":[{"content":"lexical","children":[],"payload":{"lines":"11,12"}},{"content":"syntax","children":[],"payload":{"lines":"12,13"}},{"content":"sementic","children":[],"payload":{"lines":"13,14"}}],"payload":{"lines":"10,14"}},{"content":"linker errors","children":[],"payload":{"lines":"14,15"}},{"content":"runtime errors","children":[],"payload":{"lines":"15,16"}}],"payload":{"lines":"8,16"}},{"content":"2 pass compiler architecture and its advantages","children":[],"payload":{"lines":"16,17"}}],"payload":{"lines":"1,17"}},{"content":"1st pass ( High level Code → Intermediate Code ) ( hardware independent )","children":[{"content":"Lexical Analysis","children":[{"content":"what happens in this phase ? ( character stream → token stream ) → its checked if valid “words” are given as input","children":[],"payload":{"lines":"19,20"}},{"content":"symbol table created here . but used in every phase","children":[],"payload":{"lines":"20,21"}},{"content":"Types of tokens","children":[{"content":"keywords | ( sizeOf is a keyword and an operator but (exit,main) are not keywords)","children":[],"payload":{"lines":"22,23"}},{"content":"operators","children":[],"payload":{"lines":"23,24"}},{"content":"identifiers","children":[],"payload":{"lines":"24,25"}},{"content":"constants","children":[],"payload":{"lines":"25,26"}},{"content":"special tokens","children":[],"payload":{"lines":"26,27"}}],"payload":{"lines":"21,27"}},{"content":"counting / finding tokens from the input string","children":[],"payload":{"lines":"27,28"}},{"content":"lexical error examples","children":[],"payload":{"lines":"28,29"}}],"payload":{"lines":"18,29"}},{"content":"Syntax Analysis","children":[{"content":"what happens in this phase ? ( token stream → parse tree ) → its checked if valid “grammar” (structure) is being followed","children":[],"payload":{"lines":"30,31"}},{"content":"finding syntax error in code","children":[],"payload":{"lines":"31,32"}},{"content":"CFG ( context free grammar )","children":[{"content":"Grammar = ( Variables , Terminals , Productions , Start symbol )","children":[],"payload":{"lines":"33,34"}},{"content":"used here since it deals with structure only ( i.e no context needed/checked here )","children":[],"payload":{"lines":"34,35"}},{"content":"Derivation of string","children":[{"content":"Left most derivation","children":[],"payload":{"lines":"36,37"}},{"content":"Right most derivation","children":[],"payload":{"lines":"37,38"}},{"content":"Parse tree","children":[],"payload":{"lines":"38,39"}}],"payload":{"lines":"35,39"}},{"content":"Ambiguity of grammar","children":[],"payload":{"lines":"39,40"}},{"content":"logic and formula for elemination of left recursion (direct &amp; indirect) ( since infinite loop when using LMD with grammar having left recursion )","children":[],"payload":{"lines":"40,41"}},{"content":"left factoring ( removing common left prefix to prevent backtracking problem in top down parser )","children":[],"payload":{"lines":"41,42"}},{"content":"Calculating FIRST(X) SET","children":[],"payload":{"lines":"42,43"}},{"content":"Calculating FOLLOW(X) SET","children":[],"payload":{"lines":"43,44"}}],"payload":{"lines":"32,44"}},{"content":"Parsers ( syntax analyzers )","children":[{"content":"what is parser ?","children":[],"payload":{"lines":"45,46"}},{"content":"TDP vs BUP","children":[],"payload":{"lines":"46,47"}},{"content":"Top down parsers","children":[{"content":"Reads Left to right &amp; follows LMD | start from S and produce the string","children":[],"payload":{"lines":"48,49"}},{"content":"parser configuration ( structure )","children":[],"payload":{"lines":"49,50"}},{"content":"LL1 parser","children":[{"content":"ways to implemnt LL1","children":[{"content":"recursive","children":[],"payload":{"lines":"52,53"}},{"content":"tabular","children":[],"payload":{"lines":"53,54"}}],"payload":{"lines":"51,54"}},{"content":"How to write LL1 CFG","children":[],"payload":{"lines":"54,55"}},{"content":"How to crate LL1 Table","children":[],"payload":{"lines":"55,56"}},{"content":"How to identify LL1 CFG","children":[],"payload":{"lines":"56,57"}},{"content":"sufficient condition for CFG to be LL1 ( each cell in LL1 table have atmost 1 entry )","children":[],"payload":{"lines":"57,58"}},{"content":"LL parsing algorithm","children":[],"payload":{"lines":"58,59"}},{"content":"Conflits in LL1 parsing","children":[{"content":"N ( non terminal ) conflict","children":[],"payload":{"lines":"60,61"}},{"content":"T ( terminal ) conflict","children":[],"payload":{"lines":"61,62"}}],"payload":{"lines":"59,62"}}],"payload":{"lines":"50,62"}},{"content":"LL(k) parsers and properties","children":[],"payload":{"lines":"62,63"}}],"payload":{"lines":"47,63"}},{"content":"Bottom up parsers","children":[{"content":"Reads Left to right &amp; follows Reverse of RMD | start from input string and come to S","children":[],"payload":{"lines":"64,65"}},{"content":"LR0 &lt; SLR &lt; LALR &lt; CLR (LR1)","children":[],"payload":{"lines":"65,66"}},{"content":"DFA construction for different BUP","children":[{"content":"shift , reduce , accept items","children":[],"payload":{"lines":"67,68"}},{"content":"Calculating Closure","children":[],"payload":{"lines":"68,69"}},{"content":"Calculating GOTO","children":[],"payload":{"lines":"69,70"}},{"content":"Calculating Look Ahead ( only for CLR and LALR )","children":[],"payload":{"lines":"70,71"}}],"payload":{"lines":"66,71"}},{"content":"Conflicts for differnet BUP ( SR and RR )","children":[],"payload":{"lines":"71,72"}},{"content":"Calcluating number of conflicting states in DFA","children":[],"payload":{"lines":"72,73"}},{"content":"what error is possible &amp; impossible  when CLR’s states are merged to create LALR respectively ? → RR &amp; SR","children":[],"payload":{"lines":"73,74"}},{"content":"Table consruction","children":[{"content":"shift entries","children":[],"payload":{"lines":"75,76"}},{"content":"accept entries","children":[],"payload":{"lines":"76,77"}},{"content":"reduce entries ( different for LR0 , SLR , LALR , CLR )","children":[],"payload":{"lines":"77,78"}},{"content":"GOTO entries ( only for goto table )","children":[],"payload":{"lines":"78,79"}}],"payload":{"lines":"74,79"}},{"content":"LR parsing Algorithm","children":[],"payload":{"lines":"79,80"}}],"payload":{"lines":"63,80"}},{"content":"Relations among different ( parsers , grammars , classes of language generated by grammars )","children":[],"payload":{"lines":"80,81"}},{"content":"LMD vs RMD vs Reverse of RMD","children":[],"payload":{"lines":"81,82"}}],"payload":{"lines":"44,82"}},{"content":"Precedence Relations","children":[{"content":"what is precedence relation","children":[],"payload":{"lines":"83,84"}},{"content":"how to calculate prioirty &amp; associativity of operators → ( use precidence table ) ( trick : left / right recursion with operator then that operator is left / right associative , respectively )","children":[],"payload":{"lines":"84,85"}},{"content":"what is operator grammar → no null production and no 2 non-terminal together","children":[],"payload":{"lines":"85,86"}}],"payload":{"lines":"82,86"}},{"content":"CYK algo → member ship algo of CFG ( tells if w belongs to L(G) , where G is CFG ) → time complexity O(n^3)","children":[],"payload":{"lines":"86,87"}},{"content":"for every DCFL , LL1 CFG exists and vice versa","children":[],"payload":{"lines":"87,88"}}],"payload":{"lines":"29,88"}},{"content":"Syntax Directed Translation ( also used for sementic analysis )","children":[{"content":"Syntax ( CFG i.e. grammar ) + Directed ( since order of productions and translation matters ) + Translation ( giving meaning to production rules , ex A→B#C means A = B+C or B*C )","children":[],"payload":{"lines":"89,90"}},{"content":"application of SDTs","children":[],"payload":{"lines":"90,91"}},{"content":"lexitcal Vs Syntax Vs Sementic Vs SDT","children":[],"payload":{"lines":"91,92"}},{"content":"Type of Attributes ( Inherited (derived from sibling or parent) , Synthesized (derived from child))","children":[],"payload":{"lines":"92,93"}},{"content":"Type of SDTs ( L - attributed , S - attributed ) → depends on location of Translation and type of attributes","children":[],"payload":{"lines":"93,94"}},{"content":"Evaluation of SDTs ( Left to right ( depends on Translation order ) , Bottom up parsing ( reverse of RMD ) , Top down parsing ( LMD) , NOTE : BUP and TDP , doesnt depend on translation order )","children":[],"payload":{"lines":"94,95"}}],"payload":{"lines":"88,95"}}],"payload":{"lines":"17,95"}},{"content":"2nd pass ( Intermediate Code → Target Code ) ( hardware dependent )","children":[{"content":"Intermediate Code Generation","children":[{"content":"Intermediate Code representation ( postfix , Three Adress Code , Static Single Assignment , Syntax Tree , Directed Acyclic Graph , Control Flow Graph )","children":[],"payload":{"lines":"97,98"}},{"content":"Three Adress Code Notation ( triple , quadruple , indirect triple )","children":[],"payload":{"lines":"98,99"}},{"content":"Three Adress Code for ( if - else , while loop , accessing 2d array element )","children":[],"payload":{"lines":"99,100"}},{"content":"Control Flow Graph → consists of nodes &amp; edges &amp; Basic Blocks ( 4 rules for a valid BB )","children":[],"payload":{"lines":"100,101"}}],"payload":{"lines":"96,101"}},{"content":"Code optimisation techniques","children":[{"content":"constant folding","children":[],"payload":{"lines":"102,103"}},{"content":"copy propogation → constant &amp; variable","children":[],"payload":{"lines":"103,104"}},{"content":"common subexpression elemination","children":[],"payload":{"lines":"104,105"}},{"content":"strength reduction","children":[],"payload":{"lines":"105,106"}},{"content":"algebraic simplifications","children":[],"payload":{"lines":"106,107"}},{"content":"dead code elemination","children":[],"payload":{"lines":"107,108"}},{"content":"loop optimisation → code motion , induction variable elemniation , loop mergin , loop unrolling","children":[],"payload":{"lines":"108,109"}}],"payload":{"lines":"101,109"}},{"content":"Data Flow Analysis (optimization technique )","children":[{"content":"Live variable analysis","children":[{"content":"what is a live variable ?","children":[],"payload":{"lines":"111,112"}},{"content":"calculating live variable at a statement Si","children":[],"payload":{"lines":"112,113"}}],"payload":{"lines":"110,113"}},{"content":"Backward analysis to obtain live variable at start and end of every Basic Block in the code","children":[{"content":"KILL , GEN , IN , OUT sets calculation","children":[],"payload":{"lines":"114,115"}},{"content":"INk = (OUTk - KILLk) U GENk","children":[],"payload":{"lines":"115,116"}},{"content":"OUTk = union of all the INset of its next Basic blocks","children":[],"payload":{"lines":"116,117"}}],"payload":{"lines":"113,117"}},{"content":"Reaching Definition","children":[{"content":"USE-DEF chain ( where read → where write )","children":[],"payload":{"lines":"118,119"}},{"content":"DEF-USE chain ( where write → where read )","children":[],"payload":{"lines":"119,120"}}],"payload":{"lines":"117,120"}},{"content":"Dominator Sequence , Tree , elements","children":[],"payload":{"lines":"120,121"}}],"payload":{"lines":"109,121"}},{"content":"Code Generation ( Intermediate code → assembly Code )","children":[{"content":"hardware dependent , must have knowledge of H/w architecture","children":[],"payload":{"lines":"122,123"}},{"content":"register allocation using graph colouring algorithm","children":[],"payload":{"lines":"123,124"}}],"payload":{"lines":"121,124"}},{"content":"Runtime environment","children":[{"content":"parameter passing ( by value &amp; by reference )","children":[],"payload":{"lines":"125,126"}},{"content":"memory alloation ( static , dynamic ( stack , heap ) )","children":[],"payload":{"lines":"126,127"}},{"content":"activation record","children":[],"payload":{"lines":"127,128"}}],"payload":{"lines":"124,128"}}],"payload":{"lines":"95,128"}}],"payload":{"lines":"0,128"}},null)</script>
</body>
</html>
